#!/usr/bin/python
# -*- coding:utf-8 -*-
"""Define some useful functions.
   Dependecies:
     None.
"""
__author__ = 'Jason Wong(wwssttt@163.com)'
__version__ = '1.0'

# import modules
import math
import smtplib
from email.mime.text import MIMEText
from hashlib import md5
import sys
import numpy
import const
import persist

# reload sys config and set default encoding as utf-8
reload(sys)
sys.setdefaultencoding('utf-8')

def cosineSim(topicDict1,topicDict2):
  """Calculate cosine similarity of two songs.
     Each song can be represented as a dictionary with topic index as
     key and probability as value. 
     Input:
       topicDict1 - the topic probability distribution of first song
       topicDict2 - the topic probability distribution of second song
     Output:
       cosine similarity of two songs
  """
  dotProduct = 0.0
  dictPower1 = 0.0
  dictPower2 = 0.0
  for key in topicDict1.keys():
    if key not in topicDict2:
      print '%d is not in another dict...' % key
      return
    else:
      dotProduct = dotProduct + topicDict1[key] * topicDict2[key]
      dictPower1 = dictPower1 + topicDict1[key]**2
      dictPower2 = dictPower2 + topicDict2[key]**2
  cosSimilarity = dotProduct / (math.sqrt(dictPower1) * math.sqrt(dictPower2))
  return cosSimilarity

#calculate cosine similarity of two users
#input are history list of user
#output is similarity of the two users
def cosineSimOfUser(list1,list2):
  """Calculate cosine similarity of two users.
  Each user can be represented as a list and the element in 
  teh list is the count of specific item. 
  Input:
    list1 - the history of first user
    list2 - the history of second user
  Output:
    cosine similarity of two users.
  """
  dotProduct = 0.0
  dictPower1 = 0.0
  dictPower2 = 0.0
  count1 = len(list1)
  count2 = len(list2)
  if count1 != count2:
    print 'Two list have different lengths...'
    return -1
  for i in range(count1):
    dotProduct = dotProduct + list1[i] * list2[i]
    dictPower1 = dictPower1 + list1[i]**2
    dictPower2 = dictPower2 + list2[i]**2
  similarity = dotProduct / (math.sqrt(dictPower1) * math.sqrt(dictPower2))
  return similarity

def KLDis(topicDict1,topicDict2):
  """Calculate KL distance of the first song to the second song.
     Each song can be represented as a dictionary with topic index as
     key and probability as value. 
     Note: KL distance is directed.
     Input:
       topicDict1 - the topic probability distribution of first song
       topicDict2 - the topic probability distribution of second song
     Output:
       KL distance of the first song to the second song.
  """
  distance = 0
  for key in topicDict1.keys():
    if key not in topicDict2:
      print '%d is not in another dict...' % key
      return
    else:
      pro1 = topicDict1[key]
      pro2 = topicDict2[key]
      # zero is not legal probability
      # so set it to a small value
      if pro1 <= 0:
        pro1 = 1.0 / 10000000
      if pro2 <= 0:
        pro2 = 1.0 / 10000000
      distance = distance + pro1 * math.log(pro1 / pro2)
  return distance

def KLDis(topicDict1,topicDict2):
  """Calculate the average KL distance of two songs.
     Each song can be represented as a dictionary with topic index as
     key and probability as value. 
     Note: KL distance is directed, that's why we do an average operation.
     Input:
       topicDict1 - the topic probability distribution of first song
       topicDict2 - the topic probability distribution of second song
     Output:
       KL distance of two songs.
  """
  dis1 = KLDis(topicDict1,topicDict2)
  dis2 = KLDis(topicDict2,topicDict1)
  return (dis1 + dis2) / 2.0

def HellDis(topicDict1,topicDict2):
  """Calculate the Hellinger distance of two songs.
     Each song can be represented as a dictionary with topic index as
     key and probability as value. 
     Note: Hellinger distance is undirected.
     Input:
       topicDict1 - the topic probability distribution of first song
       topicDict2 - the topic probability distribution of second song
     Output:
       KL distance of two songs.
  """
  K = len(topicDict1)
  hellDis = 0
  for key in topicDict1.keys():
    if key not in topicDict2:
      print '%d is not in another dict...' % key
      return
    else:
      # zero is not legal probability
      # so set it to a small value
      if topicDict1[key] < 0:
        topicDict1[key] = 1.0 / 10000000
      if topicDict2[key] < 0:
        topicDict2[key] = 1.0 / 10000000
      hellDis += (math.sqrt(topicDict1[key]) - math.sqrt(topicDict2[key]))**2
  hellDis = math.sqrt(hellDis)
  hellDis = hellDis * (1.0/math.sqrt(2))
  return hellDis

def similarity(topicDict1,topicDict2,disType = 0):
  """Get distance of two songs.
  Each song can be represented as a dictionary with topic index as
  key and probability as value. 
  Input:
    topicDict1 - the topic probability distribution of first song
    topicDict2 - the topic probability distribution of second song
    disType - distance type:Hellinger(0),KL(1) and default is 0.
  """
  if disType == 0:
    return HellDis(topicDict1,topicDict2)
  if disType == 1:
    return KLDis(topicDict1,topicDict2)

#calculate recall,preision and F1-Score
def getTopNIndex(recDict,playlistDict,topN = const.TOP_N):
  """ Calculate hit ration, precision and f1 score of playlists in specific scale.
  Input:
    recDict - recommend dictionaries with pid as key and recommend list as value
    playlistDict - playlist dictionaries with pid as key and Playlist as value
    topN - recommend how many songs to user
  Output:
    Hit Ration, Precision, F1 Score.
  """
  if topN < 0:
    print 'topN should be > 0'
    return 0
  hit = 0
  testNum = len(playlistDict)
  total = 0
  for pid in playlistDict.keys():
    playlist = playlistDict[pid]
    lastSid = playlist.getLastSid() # get real song
    recList = recDict[pid] # get recommend songs
    recNum = len(recList)
    if recNum >= topN:
      recNum = topN
    newList = recList[0:recNum] # recomend topN songs to user
    total = total + recNum
    if lastSid in newList: # if real song in recommend list, a hit got.
      hit = hit + 1
  recall = float(hit * 1.0) / testNum
  if total == 0:
    total = 1
  precision = float(hit * 1.0) / total
  if recall == 0 and precision == 0:
    f1 = 0
    print 'recall = 0 and precision = 0'
  else:
    f1 = 2 * ((recall * precision) / (recall + precision))
  return recall,precision,f1

def getMAEandRMSE(recDict,playlistDict,songDict,topN = const.TOP_N):
  """ Calculate mae and rmse of playlists in specific scale.
  Input:
    recDict - recommend dictionaries with pid as key and recommend list as value
    playlistDict - playlist dictionaries with pid as key and Playlist as value
    topN - recommend how many songs to user
  Output:
    MAE,RMSE.
  """
  if topN < 0:
    print 'topN should be > 0'
    return 0
  mae = 0
  rmse = 0
  testNum = len(playlistDict)
  for pid in playlistDict.keys():
    playlist = playlistDict[pid]
    lastSid = playlist.getLastSid() # get the real song
    tarDict = songDict[lastSid].getTopicDict() # get the topic dictionary of real song
    recList = recDict[pid] # get recommend lists
    recNum = len(recList)
    if recNum >= topN:
      recNum = topN
    totalError = 0
    # calculate total distances between songs in recommend list and real song
    for i in range(0,recNum):
      recSid = recList[i]
      recTopicDict = songDict[recSid].getTopicDict()
      recError = similarity(recTopicDict,tarDict)
      totalError += recError
    if recNum == 0:
      recNum = 0.0001
    # get average distance and mae, rmse
    avgError = float(totalError*1.0) / recNum
    mae = mae + math.fabs(avgError)
    rmse = rmse + avgError**2
  mae = mae / testNum
  rmse = rmse / (testNum - 1)
  rmse = math.sqrt(rmse)
  return mae,rmse

def getMethodName(mid):
  """Get method name according to method id.
     Input:
       mid - method id(ids are defined in module const).
     Output:
       method name
  """
  if mid == const.ARIMA:
    return "MTSA"
  elif mid == const.SIMILAR:
    return "Local"
  elif mid == const.AVG:
    return "Global"
  elif mid == const.ARIMA_SIMILAR:
    return "MTSA_Local"
  elif mid == const.ARIMA_AVG:
    return "MTSA_Global"
  elif mid == const.KNN:
    return "UserKNN"
  elif mid == const.MARKOV:
    return "1st-Markov"
  elif mid == const.PATTERN:
    return "PatternMining"
  elif mid == const.MARKOV_3:
    return "3rd-Markov"
  elif mid == const.ALL_HYBRID:
    return "MTSA_ALL"
  else:
    print '%d does not exist......' % mid
    return

def getIndexName(index):
  """Get validation name according to index.
     Input:
       index - validation index.
       0 : Hit Ration
       1 : Precision
       2 : F1-Score
       3 : MAE
       4 : RMSE
     Output:
       validation name.
  """
  if index == 0:
    return "Hit Ratio"
  elif index == 1:
    return "Precision"
  elif index == 2:
    return "F1-Score"
  elif index == 3:
    return "MAE"
  elif index == 4:
    return "RMSE"
  else:
    print '%d does not exist......' % index
    return

def getMD5(string):
  """Get md5 string of a string.
     Input:
       string - source string.
     Output:
       md5 of source string.
  """
  m = md5()
  m.update(string)
  return m.hexdigest()

def sendMail(to,subtitle,content):
    """Send mail to somebody with subject title and content.
       Input:
         to - target email address.
         subtitle - subject title of the email.
         content - content of the email.
       Output:
         Status of operation.
         True - success.
         False - fail.
    """
    #定义发送列表
    #mailto_list = ['wwssttt@163.com']
    #设置服务器
    mail_host = 'smtp.163.com'
    mail_port = '25'
    mail_user = 'wwssttt'
    mail_password = 'hxl111wst'
    mail_postfix = '163.com'
    me = mail_user+'<'+mail_user+'@'+mail_postfix+'>'
    msg = MIMEText(content)
    msg['Subject'] = subtitle
    msg['From'] = mail_user+'@'+mail_postfix
    msg['To'] = to
    try:
        send_smtp = smtplib.SMTP()
        send_smtp.connect(mail_host,mail_port)
        send_smtp.login(mail_user,mail_password)
        send_smtp.sendmail(me,to,msg.as_string())
        send_smtp.close()
        print 'success'
        return True
    except Exception as e:
        print(str(e))
        print 'false'
        return False

#
def getUserSongMatrix(allPlaylist,songDict):
  """Construct user-song matrix with songDict and playlistDict.
     Input:
       allPlaylist - all playlists in dataset.
       songDict - all songs in dataset.
     Output:
       pid2Index - a dictionary with pid as key and index in matrix as value.
       index2Pid - a dictionary with index in matrix as key and pid as value.
       matrix - the user-song matrix and the value is
                how many times the user listened to the song.
  """
  print 'I am in getUserSongMatrix......'
  #map id to index
  id2Index = {}
  pid2Index = {}
  index2Pid = {}
  for sid in songDict.keys():
    song = songDict[sid]
    id2Index[sid] = song.getIndex()
  sCount = len(songDict)
  pCount = 0 
  # get all users
  for scale in range(10):
    pCount += len(allPlaylist[scale])

  print 'There are %d users and %d songs.' % (pCount,sCount)

  #initail all element to zero
  matrix =[[0 for i in range(sCount)] for j in range(pCount)]
  #construct the matrix
  pIndex = 0
  for scale in range(10):
    playlistDict = allPlaylist[scale]
    for pid in playlistDict.keys():
      playlist = playlistDict[pid]
      trainingList = playlist.getTrainingList()
      pid2Index[pid] = pIndex
      index2Pid[pIndex] = pid
      for sid in trainingList:
        sIndex = id2Index[sid]
        matrix[pIndex][sIndex] += 1
      pIndex += 1
  print 'I am out getUserSongMatrix......'
  return pid2Index,index2Pid,matrix

def getUserSimMatrix(countMatrix,pid2Index):
  """Get user similarity matrix.
     Input:
       countMatrix - the user-song matrix get from getUserSongMatrix.
       pid2Index - the pid2Index dictionary get from getUserSongMatrix.
     Output:
       simMatrix - user similarity matrix.
  """
  print 'I am in getUserSimMatrix....'
  pCount = len(pid2Index)
  # initialize the similarity matrix
  simMatrix = [[-1 for i in range(pCount)] for j in range(pCount)]
  for i in range(pCount):
    for j in range(pCount):
      if simMatrix[i][j] == -1:
        simMatrix[i][j] = cosineSimOfUser(countMatrix[i],countMatrix[j])
        simMatrix[j][i] = simMatrix[i][j]
  print 'I am out getUserSimMatrix....'
  return simMatrix

def getDominantTopicDict(songDict):
  """Get teh dominant topics of all songs.
     Input:
       songDict - all songs in database.
     Output:
       domDict - dominant topic dictionaries with sid as key 
                 and dominant topics as value.
  """
  domDict = {}

  for sid in songDict.keys():
    song = songDict[sid]
    topicDict = song.getTopicDict()
    topicList = sorted(topicDict.iteritems(),key=lambda x:-x[1])
    result = []
    for index in range(len(topicList)):
      tid = int(topicList[index][0])
      tpro = float(topicList[index][1])
      #set threshold to 0.20
      if tpro >= 0.20:
        result.append(tid)
    if len(result) == 0:
      result.append(int(topicList[0][0]))
    domDict[sid] = result

  return domDict

#construct training set of playlist to mining frequent mining
def getPatternTrainingSet(allPlaylist,songDict,scale):
  """Get frequent patterns of playlists.
     Input:
       allPlaylist - all playlists in database.
       songDict - all songs in database.
       scale - scale number of playlist.
     Output:
       allTrainingPattern - frequent patterns in training set.
       testingPatternDict - frequent patterns in testing set 
                            with pid as key and pattern as value.
  """
  domDict = getDominantTopicDict(songDict)
  allTrainingPattern = []
  testingPatternDict = {}
  for part in range(10):
    if part == scale:
      continue
    playlistDict = allPlaylist[part]
    for pid in playlistDict.keys():
      playlist = playlistDict[pid]
      trainingList = playlist.getTrainingList()
      patternList = []
      for sid in trainingList:
        patternList.append(domDict[sid])
      lastSid = playlist.getLastSid()
      patternList.append(domDict[lastSid])

      allTrainingPattern.append(patternList)
     
  #testing
  playlistDict = allPlaylist[scale]
  for pid in playlistDict.keys():
    playlist = playlistDict[pid]
    trainingList = playlist.getTrainingList()
    patternList = []
    for sid in trainingList[-8:]:
      patternList.append(domDict[sid])
    
    testingPatternDict[pid] = patternList  

  return allTrainingPattern,testingPatternDict

def getTransitionMatrix(allPlaylist,songDict,scale):
  """Get first order markov transition matrix of playlists.
     Input:
       allPlaylist - all playlists in database.
       songDict - all songs in database.
       scale - scale number of playlist.
     Output:
       domDict - dominant topic dictionaries 
                 with sid as key and dominant topics as value.
       transMatrix - first order markov transition matrix.
  """
  domDict = getDominantTopicDict(songDict)
  print 'I am in constructing transition matrix...'
  transMatrix = [[1.0 for i in range(const.TOPIC_NUM)] for j in range(const.TOPIC_NUM)]

  size = len(songDict)
  
  for part in range(10):
    if part == scale:
      continue
    playlistDict = allPlaylist[part]
    for pid in playlistDict.keys():
      playlist = playlistDict[pid]
      trainingList = playlist.getTrainingList()
      length = len(trainingList)
      #remove last sid
      length -= 1
      #construct frequency matrix
      for index in range(length):
        sid = trainingList[index]
        topicList = domDict[sid]
        nextSid = trainingList[index+1]
        nextTopicList = domDict[nextSid]
        for i in range(len(topicList)):
          tid = topicList[i]
          for j in range(len(nextTopicList)):
            nextTid = nextTopicList[j]
            transMatrix[tid][nextTid] += 1.0

      sid = trainingList[length]
      topicList = domDict[sid]
      nextSid = playlist.getLastSid()
      nextTopicList = domDict[nextSid]
      for i in range(len(topicList)):
        tid = topicList[i]
        for j in range(len(nextTopicList)):
          nextTid = nextTopicList[j]
          transMatrix[tid][nextTid] += 1.0

  #construct transition matrix
  for tidIndex in range(const.TOPIC_NUM):
    total = sum(transMatrix[tidIndex])
    for nextTidIndex in range(const.TOPIC_NUM):
      transMatrix[tidIndex][nextTidIndex] = transMatrix[tidIndex][nextTidIndex] / total

  #print transMatrix

  print 'I am out constructing transition matrix...'
  return domDict,transMatrix

def getThreeOrderTransitionMatrix(allPlaylist,songDict,scale):
  """Get third order markov transition matrix of playlists.
     Input:
       allPlaylist - all playlists in database.
       songDict - all songs in database.
       scale - scale number of playlist.
     Output:
       domDict - dominant topic dictionaries 
                 with sid as key and dominant topics as value.
       transMatrix - third order markov transition matrix.
  """
  domDict = getDominantTopicDict(songDict)
  print 'I am in constructing transition matrix...'
  transDict = {}

  size = len(songDict)
  
  for part in range(10):
    if part == scale:
      continue
    playlistDict = allPlaylist[part]
    for pid in playlistDict.keys():
      playlist = playlistDict[pid]
      trainingList = playlist.getTrainingList()
      length = len(trainingList)
      #remove last sid
      length -= 3
      #construct frequency matrix
      for index in range(length):
        startSid = trainingList[index]
        startTopicList = domDict[startSid]
        secondSid = trainingList[index+1]
        secondTopicList = domDict[secondSid]
        threeSid = trainingList[index+2]
        threeTopicList = domDict[threeSid]
        targetSid = trainingList[index+3]
        targetTopicList = domDict[targetSid]
        for i in range(len(startTopicList)):
          for j in range(len(secondTopicList)):
            for s in range(len(threeTopicList)):
              key = '%d#%d#%d' % (startTopicList[i],secondTopicList[j],threeTopicList[s])
              if key not in transDict:
                transDict[key] = {}
              for t in range(len(targetTopicList)):
                tid = targetTopicList[t]
                if tid not in transDict[key]:
                  transDict[key][tid] = 1.0
                transDict[key][tid] += 1.0


      startSid = trainingList[length]
      startTopicList = domDict[startSid]
      secondSid = trainingList[length+1]
      secondTopicList = domDict[secondSid]
      threeSid = trainingList[length+2]
      threeTopicList = domDict[threeSid]
      targetSid = playlist.getLastSid()
      targetTopicList = domDict[targetSid]
      for i in range(len(startTopicList)):
        for j in range(len(secondTopicList)):
          for s in range(len(threeTopicList)):
            key = '%d#%d#%d' % (startTopicList[i],secondTopicList[j],threeTopicList[s])
            if key not in transDict:
              transDict[key] = {}
            for t in range(len(targetTopicList)):
              tid = targetTopicList[t]
              if tid not in transDict[key]:
                transDict[key][tid] = 1.0
              transDict[key][tid] += 1.0

  #construct transition matrix
  for key in transDict.keys():
    total = sum(transDict[key].values())
    for subKey in transDict[key].keys():
      transDict[key][subKey] = transDict[key][subKey] / total

  #print transMatrix

  print 'I am out constructing transition matrix...'
  return domDict,transDict
