#!/usr/bin/python
# -*- coding:utf-8 -*-
"""Store sth to file or Read sth from file.
   Dependencies:
     model.
     predict.
     const.
"""
__author__ = 'Jason Wong'
__version__ = '1.0'

import os
import model
import predict
import sys
import const
import MySQLdb

# set default encoding
reload(sys)
sys.setdefaultencoding('utf-8')

def writeTopicDictOfArimaToFile(playlistDict,songDict,scale,maxLength):
  """Write topic dictionary of predicted song to file to avoid re-computation.
     Input:
       playlistDict - playlist dict with pid as key and Playlist as value.
       songDict - song dict with sid as key and Song as value.
       scale - scale of playlists.
       maxLength - max length of source sequence.
     Output:
       None.
  """
  print 'Begin tp write topic dict to file......'
  # -1 means all songs.
  if maxLength != -1:
    filename = "../txt/length_%d_%s_arima_%d_%d.txt" \
               % (maxLength,const.DATASET_NAME,const.TOPIC_NUM,scale)
  else:
    filename = "../txt/%s_arima_%d_%d.txt" \
               % (const.DATASET_NAME,const.TOPIC_NUM,scale)
  # if the file exists in disk then return.
  if os.path.exists(filename):
    print '%s is existing......' % filename
    return
  print 'Begin to write topic dict to file......'
  aFile = open(filename,"w")
  index = 0
  many = len(playlistDict)
  # predict all playlists' next songs and store them into file.
  for pid in playlistDict.keys():
    print 'Write Arima: scale = %d >> %d/%d' % (scale,index,many)
    index += 1
    playlist = playlistDict[pid]
    predictTopicDict = predict.topicDictForNextSongByArima(playlist,
                                                           songDict,
                                                           maxLength)
    content = '%d#' % pid
    for topic in predictTopicDict.keys():
      content = '%s%d:%f,' % (content,topic,predictTopicDict[topic])
    content = content[:len(content)-1]
    aFile.write(content+"\n")
  aFile.close()
  print 'End of writing topic dict to file......'

def readPredictedTopicDictOfArima(playlistDict,songDict,scale,maxLength):
  """Read topic dictionary of predicted song from file.
     Input:
       playlistDict - playlist dict with pid as key and Playlist as value.
       songDict - song dict with sid as key and Song as value.
       scale - scale of playlists.
       maxLength - max length of source sequence.
     Output:
       predictDict - topic dict of predicted songs 
                     with pid as key and topic dict as value.
  """
  print 'I am reading predicted topic dict of arima......'
  # -1 means all songs
  if maxLength != -1:
    filename = "../txt/length_%d_%s_arima_%d_%d.txt" % (maxLength,const.DATASET_NAME,const.TOPIC_NUM,scale)
  else:
    filename = "../txt/%s_arima_%d_%d.txt" % (const.DATASET_NAME,const.TOPIC_NUM,scale)
  # if file doesn't exist then recompute.
  if not os.path.exists(filename):
    writeTopicDictOfArimaToFile(playlistDict,songDict,scale,maxLength)
  predictDict = {}
  aFile = open(filename,"r")
  lines = aFile.readlines()
  for line in lines:
    line = line.rstrip("\n")
    items = line.split("#")
    pid = int(items[0])
    topicDict = {}
    topics = items[1].split(",")
    for topic in topics:
      info = topic.split(":")
      tid = int(info[0])
      pro = float(info[1])
      topicDict[tid] = pro
    #normalize
    #make sum of pro equals to 1
    proSum = sum(topicDict.values())
    for tid in topicDict.keys():
      if proSum != 0:
        topicDict[tid] = topicDict[tid] / proSum
      else:
        topicDict[tid] = 1.0 / 30.0
    predictDict[pid] = topicDict
  print 'Finish reading predicted topic dict of arima......'
  return predictDict

def readSongFromFile():
  """Read all songs from file and construct song dictionary.
     Input:
       None.
     Output:
       songDict - song dict with sid as key and Song as value.
  """
  print 'I am reading songs from doc-topic file......'
  filename = "../txt/%s_songs-doc-topics_%d_%s.txt" \
             % (const.DATASET_NAME,const.TOPIC_NUM,const.LDA_LIB)
  if os.path.exists(filename):
    songDict = {}
    dtFile = open(filename,"r")
    content = dtFile.readlines()
    count = len(content)
    #loop all lines to construct all songs
    for i in range(0,count):
      items = content[i].rstrip('\n').split('>>')
      sid = int(items[0])
      topicList = eval(items[1])
      topicDict = {}
      for topic in topicList:
        tid = int(topic[0])
        tpro = float(topic[1])
        topicDict[tid] = tpro
      song = model.Song(i,sid,topicDict)
      songDict[sid] = song
    print 'There are %d songs have been read.' % len(songDict)
    dtFile.close()
    print 'Finish reading songs from doc-topic file......'
    return songDict
  else:
    print 'cannot find doc-topic file......'

def writePlaylistsToFile():
  """Write playlists of users to file.
     Input:
       None.
     Output:
       None.
  """
  filename = "../txt/%s_playlists.txt" % const.DATASET_NAME
  if os.path.exists(filename):
    print '%s is existing......' % filename
    return
  else:
    print 'Begin to write playlists......'
    pFile = open(filename,"w")
    
    conn = MySQLdb.Connect(host=const.DBHOST,user=const.DBUSER,passwd=const.DBPWD,port=const.DBPORT,charset=const.DBCHARSET)
    cur = conn.cursor()
    conn.select_db(const.DBNAME)
    cur.execute('select uid,playlist,scale from user where scale < 10 and scale != -1')
    results = cur.fetchall()
    playlistDict = {}
    scaleDict = {}
    for result in results:
      pid = result[0]
      playlist = result[1]
      scale = result[2]
      scaleDict[pid] = scale
      items = playlist.split('==>')
      pList = []
      for item in items:
        value = item.split(':')
        sid = value[0]
        pList.append(sid)
      playlistDict[pid] = pList

    cur.close()
    conn.close()

    for pid in playlistDict.keys():
      pList = playlistDict[pid]
      scale = scaleDict[pid]
      content = "%d>>%s:" % (scale,pid)
      pListStr = ','.join(pList)
      content = "%s%s" % (content,pListStr)
      pFile.write(content+'\n')
    pFile.close()
    print 'End of writing playlists......'

def writePlaylistsToFileSession():
  """Write playlists with scale of users to file.
     Input:
       None.
     Output:
       None.
  """
  conn = MySQLdb.Connect(host=const.DBHOST,user=const.DBUSER,passwd=const.DBPWD,port=const.DBPORT,charset=const.DBCHARSET)
  cur = conn.cursor()
  conn.select_db(const.DBNAME)

  filename = "../txt/%s_playlists.txt" % const.DATASET_NAME
  filename_b = "../txt/%s_playlists_backup.txt" % const.DATASET_NAME
  if not os.path.exists(filename):
    print '%s is not existing......' % filename
    return
  else:
    sFile = open(filename,'r')
    tFile = open(filename_b,'w')
    lines = sFile.readlines()
    for line in lines:
      line = line.strip('\n')
      line = line.strip('\r\n')
      items = line.split(':')
      uid = items[0]
      cur.execute("select scale from user where uid = '%s'" % uid)
      result = cur.fetchone()
      scale = result[0]
      content = '%d>>%s' % (scale,line)
      tFile.write(content+'\n')
    tFile.close()
    sFile.close()
  cur.close()
  conn.close()

def readPlaylistFromFile_Session():
  """Read session playlists from file.
     Input:
       None.
     Output:
       allPlaylist - two-dimension array of playlists
                     with scale as the 1st dim and pid as the 2nd
                     and the value is Playlist.
  """
  filename = "../txt/two_Lastfm_playlists.txt"
  if not os.path.exists(filename):
    writePlaylistsToFile()
  pFile = open(filename,"r")
  allPlaylist = [{} for scale in range(10)]
  lines = pFile.readlines()
  pIndex = 0
  for line in lines:
    line = line.rstrip('\n')
    items = line.split(":")
    pidStr = items[0]
    value = pidStr.split('>>')
    scale = int(value[0]) - 30
    pid = int(value[1])
    sids = items[1].split(",")
    pList = [int(sid) for sid in sids]
    playlist = model.Playlist(pid,scale,pList)
    allPlaylist[scale][pid] = playlist
    pIndex += 1
  print 'Thare are %d playlist have been read.' % (pIndex+1)
  return allPlaylist

def readPlaylistFromFile():
  """Read normal playlists from file.
     Input:
       None.
     Output:
       allPlaylist - two-dimension array of playlists
                     with scale as the 1st dim and pid as the 2nd
                     and the value is Playlist.
  """
  filename = "../txt/%s_playlists.txt" % const.DATASET_NAME
  if not os.path.exists(filename):
    writePlaylistsToFile()
  pFile = open(filename,"r")
  allPlaylist = [{} for scale in range(10)]
  lines = pFile.readlines()
  pIndex = 0
  for line in lines:
    line = line.rstrip('\n')
    items = line.split(":")
    pidStr = items[0]
    value = pidStr.split('>>')
    scale = int(value[0])
    pid = int(value[1])
    sids = items[1].split(",")
    pList = [int(sid) for sid in sids]
    playlist = model.Playlist(pid,scale,pList)
    allPlaylist[scale][pid] = playlist
    pIndex += 1
  print 'Thare are %d playlist have been read.' % (pIndex+1)
  return allPlaylist

def mvFileFromMalletToTxt():
  dirname = '../../../eclipse_workspace/mallet/mallet-2.0.7/data/LDA/'
  for dirpath, dirnames, filenames in os.walk(dirname):
    for filename in filenames:
      if filename.endswith('doc-topics.txt'):
        subIndex = filename.rfind('.txt')
        name = filename[:subIndex]
        topicNum = -1
        tFile = open('%s/%s' % (dirname,filename),'r')
        lines = tFile.readlines()
        count = len(lines)
        for index in range(1,count):
          line = lines[index].rstrip('\n')
          items = line.split()
          itemsCount = len(items)
          sidText = items[1]
          rIndex = sidText.rfind('/')
          sid = int(sidText[rIndex+1:])
          topicDict = {}
          tIndex = 2
          while tIndex < itemsCount:
            tid = int(items[tIndex])
            tIndex += 1
            tpro = float(items[tIndex])
            tIndex += 1
            if tid not in topicDict:
              topicDict[tid] = tpro
          if topicNum == -1:
            topicNum = len(topicDict)
            rFile = open('../txt/%s_%d_mallet.txt' % (name,topicNum),'w')
          if topicNum != len(topicDict):
            print 'Topic Number is Error'
            rFile.close()
            sys.exit()
          result = sorted(topicDict.iteritems(),key=lambda x:x[0],reverse=True)
          rFile.write('%d>>%s\n' % (sid,str(result)))
        rFile.close()
        tFile.close()
if __name__ == "__main__":
  #mvFileFromMalletToTxt()
  #readPlaylistFromFile()
  writePlaylistsToFileSession()
