#!/usr/bin/python
# -*- coding:utf-8 -*-
"""Connect to database and Generate documents of songs in database.
   Dependencies:
     const.
     util.
     lastfm.
"""
__author__ = 'Jason Wong'
__version__ = '1.0'

import MySQLdb
import sys
import numpy
import pylab as pl
import logging
import os
from nltk.stem.lancaster import LancasterStemmer
import matplotlib.pyplot as plt
import util
import const
import lastfm

# reload sys and set encoding to utf-8
reload(sys)
sys.setdefaultencoding('utf-8')
# set log's localtion and level
logging.basicConfig(filename=os.path.join(os.getcwd(),
                                         '../log/docgenerate_log.txt'),
                    level=logging.DEBUG,
                    format='%(asctime)s-%(levelname)s:%(message)s')

def readStopwordsFromFile(filename):
  """Read stop words from stopwords file.
     Input:
       filename - stopwords filename.
     Output:
       words - stop words list.
  """
  words = []
  stopfile = open(filename,"r")
  lines = stopfile.readlines()
  while line in lines:
    line = line.rstrip('\n')
    line = line.strip()
    line = line.lower()
    if line not in words:
      words.append(line)
  stopfile.close()
  return words

# get stopwords list
stopwords = readStopwordsFromFile("../txt/stopwords.txt")

def rmDir(whichdir):
  """Remove directory,no matter it is empty or not.
     Input: 
       whichdir - path of directory.
     Output:
       None.
  """
  # if directory does not exist then return.
  if not os.path.exists(whichdir):
    return
  print 'begin to rm dir %s' % whichdir
  # remove all files under the directory
  for dirpath,dirname,filenames in os.walk(whichdir):
    for filename in filenames:
      filepath = os.path.join(dirpath,filename)
      os.remove(filepath)
  print 'delete %d files in %s' % (len(filenames),whichdir)
  os.rmdir(whichdir)
  print 'end of rming dir %s' % whichdir

def addItemToDict(tagDict,tagStr,tagCount):
  """Add word info to word dictionary of a song.
     Input:
       tagDict - word dictionary of a song with word as key and count as value.
       tagStr - string of input tag.
       tagCount - how many times the tag was used to describe the song.
     Output:
       None.
       Note:the function can change the tagDict of the song.
  """
  # stemmer
  st = LancasterStemmer()
  # split tagStr
  for item in tagStr.split():
    item = item.lower()
    # stem
    item = st.stem(item)
    #remove stopwords and too short words
    if item not in stopwords:
      if item not in tagDict:
        tagDict[item] = tagCount
      else:
        tagDict[item] = tagDict[item] + tagCount

def generateTagDictofSong(sname,aname,toptag):
  """Generate tag dictionary of a song.
     Input:
       sname - title of the song.
       aname - name of the artist.
       toptag - top tags of the song(str).
     Output:
       tagDict - tag dictionary of the song with word as key, count as value.
  """
  tagDict = {}
  # add sname to tagDict
  addItemToDict(tagDict,sname,100)
  # add aname to tagDict
  addItemToDict(tagDict,aname,100)
  # split tags<tag:count>
  tagInfos = eval(toptag)
  #loop every tag Information
  for tag in tagInfos.keys():
    tagCount = tagInfos[tag]
    #avoid some tags without count
    #if a tag has no count, ignore it
    if len(tagCount) == 0:
      continue
    else:
      #add tag to dict
      #print tag,tagCount
      addItemToDict(tagDict,tag,int(tagCount))
  return tagDict

def generateDocofSong(sid,tagDict):
  """Generate document of a song.
     Input:
       sid - id of the song.
       tagDict - tag dictionary of the song with word as key, count as value.
     Output:
       final string of the song.
  """
  result = []
  #repeat: write tag into file
  for tag in tagDict.keys():
    count = (int)(tagDict[tag] / 4)
    tag = "%s " % tag
    result.append(tag*count)
  return " ".join(result)

def generateDocs():  
  """Generate documents of songs in database.
     Input:
       None.
     Output:
       None.
  """
  try:
    # connect db and select db name
    conn = MySQLdb.Connect(host=const.DBHOST,user=const.DBUSER,passwd=const.DBPWD,port=const.DBPORT,charset=const.DBCHARSET)
    cur = conn.cursor()
    conn.select_db(const.DBNAME)
    
    sids = []
    sessionFile = open('../txt/%s_playlists.txt' % const.DATASET_NAME)
    lines = sessionFile.readlines()
    for line in lines:
      line = line.strip('\n')
      line = line.strip('\r\n')
      items = line.split(':')
      songStr = items[1]
      songs = songStr.split(',')
      for song in songs:
        if song not in sids:
          sids.append(song)
    sessionFile.close()

    print '%d song are to be crawled...' % len(sids)
    return
    print 'Begin to generate docs...'
    sFile = open('../txt/%s_song_Docs.txt' % const.DATASET_NAME,'w')
    dirname = '../txt/%s_songs' % const.DATASET_NAME
    rmDir(dirname)
    os.mkdir(dirname)

    size = len(sids)
    index = 0
    for songId in sids:
      index += 1
      print 'GenerateDocs:%d/%d' % (index,size)
      sql = "select sid,name,aname,toptag from song where sid = '%s'" % songId
      count = cur.execute(sql)
      result = cur.fetchone()
      sid = result[0]
      sname = result[1]
      aname = result[2]
      toptag = result[3]
      tagDict = generateTagDictofSong(sname,aname,toptag)
      text =  generateDocofSong(sid,tagDict)
      text = text.replace('\n',' ')
      sFile.write('%s>>%s\n' % (sid,text))
      filename = '%s/%s' % (dirname,sid)
      tmpFile = open(filename,'w')
      tmpFile.write(text)
      tmpFile.close()
    sFile.close()
    print 'Finish generating docs...'
    conn.commit()
    cur.close()
    conn.close()
  except MySQLdb.Error,e:
    print 'Mysql Error %d:%s' % (e.args[0],e.args[1])
    logging.error('Mysql Error %d:%s' % (e.args[0],e.args[1]))

if __name__ == "__main__":
   print stopwords
   generateDocs()
